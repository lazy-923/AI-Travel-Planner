from fastapi import FastAPI, Request, Depends, HTTPException
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
import os
from dotenv import load_dotenv
from http import HTTPStatus
import dashscope
from supabase import create_client, Client
from pydantic import BaseModel
from typing import Optional
import aiohttp
import json
import re
import asyncio

# Supabase setup
def get_supabase():
    url: str = os.environ.get("SUPABASE_URL")
    key: str = os.environ.get("SUPABASE_ANON_KEY")
    return create_client(url, key)


# Load environment variables from .env file
load_dotenv(dotenv_path=os.path.join(os.path.dirname(os.path.dirname(__file__)), '.env'))

app = FastAPI()

# CORS configuration
origins = [
    "http://localhost",
    "http://localhost:3000",
    "http://127.0.0.1",
    "http://127.0.0.1:3000",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class HistoryItem(BaseModel):
    id: Optional[int] = None
    user_id: str
    query: str
    response: str
    city: str
    locations: str

class UpdateHistoryItem(BaseModel):
    response: str

class PreferencesData(BaseModel):
    beach: bool = False
    mountain: bool = False
    city: bool = False
    countryside: bool = False
    adventure: bool = False
    relaxation: bool = False
    culture: bool = False
    history: bool = False
    custom: str = ''

class Preferences(BaseModel):
    user_id: str
    preferences: PreferencesData


@app.post("/api/history")
def create_history_item(item: HistoryItem, supabase: Client = Depends(get_supabase)):
    """
    Create a new history item.
    """
    try:
        # Exclude 'id' if it's None, as it's auto-generated by the database
        item_dict = item.model_dump(exclude_unset=True)
        if 'id' in item_dict:
            del item_dict['id']

        response = supabase.table('history').insert(item_dict).execute()
        
        # Check if the insert was successful and data is returned
        if response.data:
            return response.data[0]
        else:
            # Handle case where insert does not return data, which might indicate an issue
            raise HTTPException(status_code=500, detail="Failed to create history item, no data returned.")

    except Exception as e:
        print(f"Error creating history item: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to create history item: {e}")


async def _geocode_address(session, address: str, city: str, api_key: str):
    """
    Asynchronously geocodes a single address within a specific city.
    """
    # URL-encode the address and city to handle special characters
    encoded_address = aiohttp.helpers.quote(address)
    encoded_city = aiohttp.helpers.quote(city)
    
    url = f"https://restapi.amap.com/v3/geocode/geo?address={encoded_address}&city={encoded_city}&key={api_key}"
    
    try:
        async with session.get(url) as response:
            if response.status == 200:
                data = await response.json()
                if data.get('status') == '1' and data.get('geocodes'):
                    # Successfully found the location
                    location = data['geocodes'][0]['location']
                    print(f"Successfully geocoded '{address}' in '{city}': {location}")
                    return location
                else:
                    # Amap API returned a valid response but found no match
                    print(f"Could not geocode '{address}' in '{city}'. Amap response: {data}")
                    return None
            else:
                # The request to Amap API failed
                print(f"Amap API request failed for '{address}' in '{city}' with status: {response.status}")
                return None
    except Exception as e:
        # An exception occurred during the request
        print(f"An exception occurred while geocoding '{address}' in '{city}': {e}")
        return None


@app.post("/api/generate")
async def generate(request: Request, supabase: Client = Depends(get_supabase)):
    body = await request.json()
    query = body.get("query")
    user_id = body.get("user_id")
    preferences = body.get("preferences", "")

    if not query or not user_id:
        raise HTTPException(status_code=400, detail="Query or user_id not provided")

    prompt = f"""你是一个专业的旅行计划助手。请根据用户的需求，生成一份详细、丰富且结构化的旅行计划。

用户的需求是：'{query}'
用户偏好：'{preferences}'

---
**你的回答必须遵循以下要求：**

1.  **内容丰富**：
    *   **每日行程 (Day-by-day Itinerary)**：为每一天制定详细的计划。
    *   **时间段划分 (Time Blocks)**：每天的计划应分为“早上”、“中午”、“下午”和“晚上”。
    *   **活动与景点 (Activities & Sights)**：在每个时间段内，清晰地列出要参观的景点或要进行的活动，并附上简要介绍。
    *   **餐饮建议 (Food Recommendations)**：在“中午”和“晚上”的时间段，推荐当地特色美食或餐厅。
    *   **实用贴士 (Practical Tips)**：在计划的最后，提供关于交通、门票预订、天气、当地习俗等实用建议。

2.  **格式严格**：
    *   你的输出**必须**是一个格式完整的JSON对象，不包含任何JSON对象之外的解释或说明文字。
    *   JSON对象必须包含以下三个键：
        1.  `city`: 一个字符串，表示本次旅行计划的核心城市。
        2.  `plan`: 一个字符串，包含格式化后的详细每日行程安排。请使用Markdown语法（例如`##`表示日期，`###`表示时间段，`-`或`*`表示列表项）来组织内容，使其清晰易读。
        3.  `locations`: 一个JSON数组，其中只包含所有在`plan`中提到的**具体地点名称**（例如景点、餐厅、公园、街道、博物馆等）。

---
**这是一个优秀的输出示例：**

```json
{{
    "city": "北京",
    "plan": "## **第一天：故宫、景山、王府井**\\n\\n### 早上：\\n- **8:00 - 12:00**：前往**故宫**（紫禁城）\\n  - 提前在官网预约门票，重点参观太和殿、乾清宫、御花园。\\n\\n### 中午：\\n- **12:00 - 13:00**：在**故宫附近**吃午饭，推荐尝试老北京炸酱面。\\n\\n### 下午：\\n- **14:00 - 15:30**：游览**景山公园**\\n  - 从故宫北门步行可达，登上万春亭俯瞰故宫全景。\\n- **16:00 - 18:00**：前往**王府井大街**\\n  - 逛逛北京最繁华的商业街。\\n\\n### 晚上：\\n- **19:00 - 21:00**：在**全聚德王府井店**享用北京烤鸭晚餐。\\n\\n---\\n\\n## **第二天：天安门广场、国家博物馆、南锣鼓巷**\\n\\n... (以此类推) ...\\n\\n---\\n\\n## **小贴士：**\\n- **交通**：建议使用地铁出行。\\n- **门票**：故宫和国家博物馆需要提前实名预约。\\n- **饮食**：大胆尝试豆汁儿、卤煮等本地特色小吃。",
    "locations": ["故宫", "景山公园", "王府井大街", "故宫附近", "全聚德王府井店", "天安门广场", "国家博物馆", "南锣鼓巷"]
}}
```

"""

    # Call Bailian API
    dashscope_response = dashscope.Generation.call(
        model='qwen-turbo',
        prompt=prompt,
        api_key=os.getenv("DASHSCOPE_API_KEY")
    )

    if dashscope_response.status_code != HTTPStatus.OK:
        raise HTTPException(status_code=500, detail="Failed to get response from Bailian API")

    ai_response_text = dashscope_response.output.text
    ai_response_json = None
    try:
        # Attempt to parse the entire JSON response directly
        ai_response_json = json.loads(ai_response_text)
    except json.JSONDecodeError:
        # If direct parsing fails, try to extract JSON from a string that might contain extra text
        json_match = re.search(r'\{.*\}', ai_response_text, re.DOTALL)
        if json_match:
            try:
                ai_response_json = json.loads(json_match.group(0))
            except json.JSONDecodeError:
                raise HTTPException(status_code=500, detail={{
                    "error": "Failed to parse JSON from AI response", 
                    "raw_response": ai_response_text
                }})
        else:
            raise HTTPException(status_code=500, detail={{
                "error": "No JSON object found in AI response", 
                "raw_response": ai_response_text
            }})

    plan = ai_response_json.get("plan")
    locations_names = ai_response_json.get("locations")
    city = ai_response_json.get("city")

    if not all([plan, isinstance(locations_names, list), city]):
        raise HTTPException(status_code=500, detail={{
            "error": "AI response is missing or has an invalid format for one or more required fields: 'plan', 'locations', 'city'", 
            "ai_response": ai_response_json
        }})

    # Geocode locations in the backend
    geocoded_locations = []
    api_key = os.getenv("AMAP_API_KEY")
    async with aiohttp.ClientSession() as session:
        tasks = [_geocode_address(session, name, city, api_key) for name in locations_names]
        results = await asyncio.gather(*tasks)
        
        for name, location_coords in zip(locations_names, results):
            geocoded_locations.append({"name": name, "location": location_coords})

    return {
        "plan": plan,
        "locations": geocoded_locations,
        "city": city
    }


@app.post("/api/history")
async def save_history(request: Request, supabase: Client = Depends(get_supabase)):
    try:
        data = await request.json()
        user_id = data.get("user_id")
        query = data.get("query")
        response = data.get("response")
        city = data.get("city")
        locations = data.get("locations")

        if not all([user_id, query, response, city, locations]):
            raise HTTPException(status_code=400, detail="Missing required fields")

        # Save to Supabase
        insert_response = supabase.table("history").insert({"user_id": user_id, "query": query, "response": response, "city": city, "locations": locations}).execute()
        if not insert_response.data:
            raise HTTPException(status_code=500, detail="Failed to save history, no data returned.")

        return {"message": "History saved successfully"}
    except Exception as e:
        print(f"Error saving history item: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/api/history/{user_id}")
def get_history(user_id: str, page: int = 1, per_page: int = 10, supabase: Client = Depends(get_supabase)):
    """
    Get history for a user.
    """
    try:
        start_index = (page - 1) * per_page
        end_index = start_index + per_page - 1

        # Get total count of items for the user
        count_response = supabase.table('history').select("id", count='exact').eq('user_id', user_id).execute()
        total_items = count_response.count

        # Get paginated history data, including city and locations
        history_response = supabase.table('history').select("id, query, response, created_at, city, locations").eq('user_id', user_id).order('created_at', desc=True).range(start_index, end_index).execute()
        history_data = history_response.data

        # Get all budget entries
        budget_response = supabase.table('budgets').select('history_id').execute()
        budgeted_history_ids = {item['history_id'] for item in budget_response.data}

        # Add 'has_budget' flag to each history item
        for item in history_data:
            item['has_budget'] = item['id'] in budgeted_history_ids

        return {
            "data": history_data,
            "total": total_items
        }
    except Exception as e:
        print(f"Error fetching history from Supabase: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch history")

@app.delete("/api/history/{item_id}")
def delete_history_item(item_id: int, supabase: Client = Depends(get_supabase)):
    """
    删除指定的历史记录
    """
    try:
        response = supabase.table('history').delete().eq('id', item_id).execute()
        if not response.data:
            raise HTTPException(status_code=404, detail="History item not found")
        return {"message": "History item deleted successfully"}
    except Exception as e:
        print(f"Error deleting history item: {e}")
        raise HTTPException(status_code=500, detail="Failed to delete history item")

@app.put("/api/history/{item_id}")
def update_history_item(item_id: int, item: UpdateHistoryItem, supabase: Client = Depends(get_supabase)):
    """
    更新指定的历史记录
    """
    try:
        response = supabase.table('history').update({'response': item.response}).eq('id', item_id).execute()
        if not response.data:
            raise HTTPException(status_code=404, detail="History item not found")
        return {"message": "History item updated successfully"}
    except Exception as e:
        print(f"Error updating history item: {e}")
        raise HTTPException(status_code=500, detail="Failed to update history item")


@app.get("/api/preferences/{user_id}")
def get_preferences(user_id: str, supabase: Client = Depends(get_supabase)):
    """
    获取用户偏好
    """
    preference_keys = [
        "beach", "mountain", "city", "countryside", 
        "adventure", "relaxation", "culture", "history", "custom"
    ]
    default_preferences = {key: False if key != 'custom' else '' for key in preference_keys}

    try:
        response = supabase.table('user_preferences').select("preferences").eq('user_id', user_id).execute()
        
        if response.data and response.data[0].get("preferences"):
            prefs_data = response.data[0]["preferences"]
            
            # Ensure all keys are present, filling missing ones with a default value
            full_prefs = default_preferences.copy()
            if isinstance(prefs_data, dict):
                full_prefs.update(prefs_data)
            
            return {"preferences": full_prefs}

        # If no data or format is wrong, return default preferences
        return {"preferences": default_preferences}
        
    except Exception as e:
        print(f"Error fetching preferences from Supabase: {e}")
        # In case of any other error, return default as a fallback
        return {"preferences": default_preferences}

@app.post("/api/preferences")
async def update_preferences(request: Request, supabase: Client = Depends(get_supabase)):
    body = await request.json()
    user_id = body.get("user_id")
    preferences_data = body.get("preferences")

    if not user_id or not preferences_data:
        raise HTTPException(status_code=400, detail="user_id or preferences not provided")

    try:
        # Validate preferences using the Pydantic model
        validated_prefs = PreferencesData(**preferences_data)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Invalid preferences format: {e}")

    try:
        # Use model_dump to get a dictionary from the Pydantic model
        prefs_dict = validated_prefs.model_dump()

        # Check if preferences for the user already exist
        existing_prefs_res = supabase.table('user_preferences').select("*").eq('user_id', user_id).execute()
        
        if existing_prefs_res.data:
            # Update existing preferences
            supabase.table('user_preferences').update({"preferences": prefs_dict}).eq('user_id', user_id).execute()
        else:
            # Insert new preferences
            supabase.table('user_preferences').insert({"user_id": user_id, "preferences": prefs_dict}).execute()
        
        return {"message": "Preferences updated successfully"}
    except Exception as e:
        print(f"Error updating preferences in Supabase: {e}")
        raise HTTPException(status_code=500, detail="Failed to update preferences")


def extract_json_from_string(s):
    # This regex finds a JSON object within a string
    match = re.search(r'\{.*\}', s, re.DOTALL)
    if match:
        try:
            return json.loads(match.group(0))
        except json.JSONDecodeError:
            return None
    return None

@app.post("/api/budget")
async def budget(request: Request):
    body = await request.json()
    plan = body.get("plan")

    if not plan:
        return {"error": "Plan not provided"}, 400

    prompt = f"""Please provide a detailed budget estimation based on the following travel plan. The response MUST be a JSON object and nothing else. Do not include any text before or after the JSON object. The JSON object should have the following structure:

    {{
        "total_budget": <Total estimated budget (number)>,
        "currency": "CNY",
        "budget_breakdown": [
            {{
                "category": "Accommodation",
                "amount": <Amount (number)>,
                "details": "<Brief explanation>"
            }},
            {{
                "category": "Transportation",
                "amount": <Amount (number)>,
                "details": "<Brief explanation>"
            }},
            {{
                "category": "Food",
                "amount": <Amount (number)>,
                "details": "<Brief explanation>"
            }},
            {{
                "category": "Activities",
                "amount": <Amount (number)>,
                "details": "<Brief explanation>"
            }},
            {{
                "category": "Other",
                "amount": <Amount (number)>,
                "details": "<Brief explanation>"
            }}
        ]
    }}

    Travel Plan:
    {plan}
    """

    # Call Bailian API
    response = dashscope.Generation.call(
        model='qwen-turbo',
        prompt=prompt,
        api_key=os.getenv("DASHSCOPE_API_KEY")
    )

    if response.status_code == HTTPStatus.OK:
        ai_response_text = response.output.text
        
        # Attempt to extract JSON from the AI's response
        budget_json = extract_json_from_string(ai_response_text)
        
        if budget_json:
            return {"budget": budget_json}
        else:
            # If no JSON is found, return an error
            return {"error": "Failed to parse budget from AI response", "raw_response": ai_response_text}, 500
    else:
        return {"error": "Failed to get response from Bailian API"}, 500

class Budget(BaseModel):
    history_id: int
    user_id: str
    budget_details: str

@app.post("/api/budgets")
def create_budget(budget: Budget, supabase: Client = Depends(get_supabase)):
    try:
        response = supabase.table('budgets').insert(budget.model_dump()).execute()
        return response.data[0]
    except Exception as e:
        print(f"Error creating budget: {e}")
        raise HTTPException(status_code=500, detail="Failed to create budget")

@app.get("/api/budgets/{history_id}")
def get_budget(history_id: int, supabase: Client = Depends(get_supabase)):
    try:
        response = supabase.table('budgets').select('*').eq('history_id', history_id).execute()
        if not response.data:
            raise HTTPException(status_code=404, detail="Budget not found")
        return response.data[0]
    except Exception as e:
        print(f"Error fetching budget: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch budget")

class Expense(BaseModel):
    id: Optional[int] = None
    user_id: str
    trip_id: int
    category: str
    amount: float
    description: str

@app.post("/api/expenses")
def create_expense(expense: Expense, supabase: Client = Depends(get_supabase)):
    try:
        response = supabase.table('expenses').insert(expense.dict(exclude_unset=True)).execute()
        return response.data[0]
    except Exception as e:
        print(f"Error creating expense: {e}")
        raise HTTPException(status_code=500, detail="Failed to create expense")

@app.get("/api/expenses/{trip_id}")
def get_expenses(trip_id: int, supabase: Client = Depends(get_supabase)):
    try:
        response = supabase.table('expenses').select('*').eq('trip_id', trip_id).execute()
        return response.data
    except Exception as e:
        print(f"Error fetching expenses: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch expenses")

@app.put("/api/expenses/{expense_id}")
def update_expense(expense_id: int, expense: Expense, supabase: Client = Depends(get_supabase)):
    try:
        response = supabase.table('expenses').update(expense.dict(exclude_unset=True)).eq('id', expense_id).execute()
        return response.data[0]
    except Exception as e:
        print(f"Error updating expense: {e}")
        raise HTTPException(status_code=500, detail="Failed to update expense")

@app.delete("/api/expenses/{expense_id}")
def delete_expense(expense_id: int, supabase: Client = Depends(get_supabase)):
    try:
        supabase.table('expenses').delete().eq('id', expense_id).execute()
        return {"message": "Expense deleted successfully"}
    except Exception as e:
        print(f"Error deleting expense: {e}")
        raise HTTPException(status_code=500, detail="Failed to delete expense")

@app.get("/api/health-check")
async def health_check():
    return {"status": "ok"}

if __name__ == "__main__":
    uvicorn.run(app, host="127.0.0.1", port=8000)